function t(t){return Math.floor(1e4*t)/100}const e=e=>{var o,s,l,i;const n=Array.from({length:e.images.length},(()=>[])),a=[];for(const r of e.ratios){let h=0,f=[],c=0;for(let o=0;o<e.images.length;o++)if(h+e.images[o].aspect_ratio<=r)h+=e.images[o].aspect_ratio;else{c=f.length;for(let s=f.length;s<o;s++){const o=t(e.images[s].aspect_ratio/h);f.push(o)}h=e.images[o].aspect_ratio}const g=f.slice(c);for(let t=1;t<g.length;t++)g[t]+=g[t-1];g.push(100);let u=0;const p=f.length;let m=0;const v=[];for(let o=f.length;o<e.images.length;o++){const s=t(e.images[o].aspect_ratio/r);for(f.push(s),m+=s;g[u]<m;)u++;v.push(g[u]/m),u>0&&v.push(g[u-1]/m)}if("fill"==e.lastRowBehavior){const t=r/h;if(1>=t*(null!==(o=e.threshold)&&void 0!==o?o:0))for(let e=p;e<f.length;e++)f[e]*=t}else if("match-previous"==e.lastRowBehavior||void 0===e.lastRowBehavior){const t=null!==(s=e.growLimit)&&void 0!==s?s:1.5,o=null!==(l=e.shrinkLimit)&&void 0!==l?l:.5,n=null!==(i=e.preferGrowing)&&void 0!==i?i:2;v.push(100/m);let a=1,r=1/0;for(const e of v)if(e>=1){const o=e;if(e>t)continue;Math.abs(o)<Math.abs(r)&&(a=e,r=o)}else{const t=n/e;if(e<o)continue;Math.abs(t)<Math.abs(r)&&(a=e,r=t)}for(let t=p;t<f.length;t++)f[t]*=a}let d=100;for(let t=p;t<f.length;t++)d-=f[t];for(const t in f)n[t].push(f[t]);a.push(d)}return[n,a]};export{e as calculateImageSizes};
//# sourceMappingURL=calculateImageSizes.js.map
