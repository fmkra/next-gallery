function t(t){return Math.floor(1e4*t)/100}const e=e=>{var o,s,l,n;const i=Array.from({length:e.images.length},(()=>[])),r=[];for(const a of e.ratios){let h=0,f=[],c=0;for(let o=0;o<e.images.length;o++)if(h+e.images[o].aspect_ratio<=a)h+=e.images[o].aspect_ratio;else{c=f.length;for(let s=f.length;s<o;s++){const o=t(e.images[s].aspect_ratio/h);f.push(o)}h=e.images[o].aspect_ratio}const g=f.slice(c);for(let t=1;t<g.length;t++)g[t]+=g[t-1];g.push(100);let u=0;const p=f.length;let m=0;const v=[];for(let o=f.length;o<e.images.length;o++){const s=t(e.images[o].aspect_ratio/a);for(f.push(s),m+=s;g[u]<m;)u++;v.push(g[u]/m),u>0&&v.push(g[u-1]/m)}if("fill"==e.lastRowBehavior){const t=a/h;if(1>=t*(null!==(o=e.threshold)&&void 0!==o?o:0))for(let e=p;e<f.length;e++)f[e]*=t}else if("match-previous"==e.lastRowBehavior){const t=null!==(s=e.growLimit)&&void 0!==s?s:1.5,o=null!==(l=e.shrinkLimit)&&void 0!==l?l:.5,i=null!==(n=e.preferGrowing)&&void 0!==n?n:2;v.push(100/m);let r=1,a=1/0;for(const e of v)if(e>=1){const o=e;if(e>t)continue;Math.abs(o)<Math.abs(a)&&(r=e,a=o)}else{const t=i/e;if(e<o)continue;Math.abs(t)<Math.abs(a)&&(r=e,a=t)}for(let t=p;t<f.length;t++)f[t]*=r}let d=100;for(let t=p;t<f.length;t++)d-=f[t];for(const t in f)i[t].push(f[t]);r.push(d)}return[i,r]};export{e as calculateImageSizes};
//# sourceMappingURL=calculateImageSizes.js.map
